{"version":3,"file":"vendors-node_modules_storybook_addon-docs_dist_esm_blocks_index_js.ebfe62679b9a8433f97c.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://fail-end/./node_modules/@storybook/addon-docs/dist/esm/blocks/ArgsTable.js","webpack://fail-end/./node_modules/@storybook/addon-docs/dist/esm/blocks/enhanceSource.js","webpack://fail-end/./node_modules/@storybook/addon-docs/node_modules/@storybook/store/dist/esm/filterArgTypes.js","webpack://fail-end/./node_modules/@storybook/addon-docs/node_modules/@storybook/store/dist/esm/parameters.js"],"sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport React, { useContext, useEffect, useState, useCallback } from 'react';\nimport mapValues from 'lodash/mapValues';\nimport { ArgsTable as PureArgsTable, ArgsTableError, TabbedArgsTable } from '@storybook/components';\nimport { addons } from '@storybook/addons';\nimport { filterArgTypes } from '@storybook/store';\nimport Events from '@storybook/core-events';\nimport { DocsContext } from './DocsContext';\nimport { CURRENT_SELECTION, PRIMARY_STORY } from './types';\nimport { getComponentName } from './utils';\nimport { lookupStoryId } from './Story';\nimport { useStory } from './useStory';\n\nvar getContext = function getContext(storyId, context) {\n  var story = context.storyById(storyId);\n\n  if (!story) {\n    throw new Error(\"Unknown story: \".concat(storyId));\n  }\n\n  return context.getStoryContext(story);\n};\n\nvar useArgs = function useArgs(storyId, context) {\n  var channel = addons.getChannel();\n  var storyContext = getContext(storyId, context);\n\n  var _useState = useState(storyContext.args),\n      _useState2 = _slicedToArray(_useState, 2),\n      args = _useState2[0],\n      setArgs = _useState2[1];\n\n  useEffect(function () {\n    var cb = function cb(changed) {\n      if (changed.storyId === storyId) {\n        setArgs(changed.args);\n      }\n    };\n\n    channel.on(Events.STORY_ARGS_UPDATED, cb);\n    return function () {\n      return channel.off(Events.STORY_ARGS_UPDATED, cb);\n    };\n  }, [storyId]);\n  var updateArgs = useCallback(function (updatedArgs) {\n    return channel.emit(Events.UPDATE_STORY_ARGS, {\n      storyId: storyId,\n      updatedArgs: updatedArgs\n    });\n  }, [storyId]);\n  var resetArgs = useCallback(function (argNames) {\n    return channel.emit(Events.RESET_STORY_ARGS, {\n      storyId: storyId,\n      argNames: argNames\n    });\n  }, [storyId]);\n  return [args, updateArgs, resetArgs];\n};\n\nvar useGlobals = function useGlobals(storyId, context) {\n  var channel = addons.getChannel();\n  var storyContext = getContext(storyId, context);\n\n  var _useState3 = useState(storyContext.globals),\n      _useState4 = _slicedToArray(_useState3, 2),\n      globals = _useState4[0],\n      setGlobals = _useState4[1];\n\n  useEffect(function () {\n    var cb = function cb(changed) {\n      setGlobals(changed.globals);\n    };\n\n    channel.on(Events.GLOBALS_UPDATED, cb);\n    return function () {\n      return channel.off(Events.GLOBALS_UPDATED, cb);\n    };\n  }, []);\n  return [globals];\n};\n\nexport var extractComponentArgTypes = function extractComponentArgTypes(component, _ref, include, exclude) {\n  var id = _ref.id,\n      storyById = _ref.storyById;\n\n  var _storyById = storyById(id),\n      parameters = _storyById.parameters;\n\n  var _ref2 = parameters.docs || {},\n      extractArgTypes = _ref2.extractArgTypes;\n\n  if (!extractArgTypes) {\n    throw new Error(ArgsTableError.ARGS_UNSUPPORTED);\n  }\n\n  var argTypes = extractArgTypes(component);\n  argTypes = filterArgTypes(argTypes, include, exclude);\n  return argTypes;\n};\n\nvar isShortcut = function isShortcut(value) {\n  return value && [CURRENT_SELECTION, PRIMARY_STORY].includes(value);\n};\n\nexport var getComponent = function getComponent() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _ref3 = arguments.length > 1 ? arguments[1] : undefined,\n      id = _ref3.id,\n      storyById = _ref3.storyById;\n\n  var _ref4 = props,\n      of = _ref4.of;\n  var _ref5 = props,\n      story = _ref5.story;\n\n  var _storyById2 = storyById(id),\n      component = _storyById2.component;\n\n  if (isShortcut(of) || isShortcut(story)) {\n    return component || null;\n  }\n\n  if (!of) {\n    throw new Error(ArgsTableError.NO_COMPONENT);\n  }\n\n  return of;\n};\n\nvar addComponentTabs = function addComponentTabs(tabs, components, context, include, exclude, sort) {\n  return Object.assign({}, tabs, mapValues(components, function (comp) {\n    return {\n      rows: extractComponentArgTypes(comp, context, include, exclude),\n      sort: sort\n    };\n  }));\n};\n\nexport var StoryTable = function StoryTable(props) {\n  var context = useContext(DocsContext);\n  var currentId = context.id,\n      componentStories = context.componentStories;\n  var storyName = props.story,\n      component = props.component,\n      subcomponents = props.subcomponents,\n      showComponent = props.showComponent,\n      include = props.include,\n      exclude = props.exclude,\n      sort = props.sort;\n\n  try {\n    var storyId;\n\n    switch (storyName) {\n      case CURRENT_SELECTION:\n        {\n          storyId = currentId;\n          break;\n        }\n\n      case PRIMARY_STORY:\n        {\n          var primaryStory = componentStories()[0];\n          storyId = primaryStory.id;\n          break;\n        }\n\n      default:\n        {\n          storyId = lookupStoryId(storyName, context);\n        }\n    }\n\n    var story = useStory(storyId, context); // eslint-disable-next-line prefer-const\n\n    var _useArgs = useArgs(storyId, context),\n        _useArgs2 = _slicedToArray(_useArgs, 3),\n        args = _useArgs2[0],\n        updateArgs = _useArgs2[1],\n        resetArgs = _useArgs2[2];\n\n    var _useGlobals = useGlobals(storyId, context),\n        _useGlobals2 = _slicedToArray(_useGlobals, 1),\n        globals = _useGlobals2[0];\n\n    if (!story) return /*#__PURE__*/React.createElement(PureArgsTable, {\n      isLoading: true,\n      updateArgs: updateArgs,\n      resetArgs: resetArgs\n    });\n    var argTypes = filterArgTypes(story.argTypes, include, exclude);\n    var mainLabel = getComponentName(component) || 'Story';\n\n    var tabs = _defineProperty({}, mainLabel, {\n      rows: argTypes,\n      args: args,\n      globals: globals,\n      updateArgs: updateArgs,\n      resetArgs: resetArgs\n    }); // Use the dynamically generated component tabs if there are no controls\n\n\n    var storyHasArgsWithControls = argTypes && Object.values(argTypes).find(function (v) {\n      return !!(v !== null && v !== void 0 && v.control);\n    });\n\n    if (!storyHasArgsWithControls) {\n      updateArgs = null;\n      resetArgs = null;\n      tabs = {};\n    }\n\n    if (component && (!storyHasArgsWithControls || showComponent)) {\n      tabs = addComponentTabs(tabs, _defineProperty({}, mainLabel, component), context, include, exclude);\n    }\n\n    if (subcomponents) {\n      if (Array.isArray(subcomponents)) {\n        throw new Error(\"Unexpected subcomponents array. Expected an object whose keys are tab labels and whose values are components.\");\n      }\n\n      tabs = addComponentTabs(tabs, subcomponents, context, include, exclude);\n    }\n\n    return /*#__PURE__*/React.createElement(TabbedArgsTable, {\n      tabs: tabs,\n      sort: sort\n    });\n  } catch (err) {\n    return /*#__PURE__*/React.createElement(PureArgsTable, {\n      error: err.message\n    });\n  }\n};\nexport var ComponentsTable = function ComponentsTable(props) {\n  var context = useContext(DocsContext);\n  var components = props.components,\n      include = props.include,\n      exclude = props.exclude,\n      sort = props.sort;\n  var tabs = addComponentTabs({}, components, context, include, exclude);\n  return /*#__PURE__*/React.createElement(TabbedArgsTable, {\n    tabs: tabs,\n    sort: sort\n  });\n};\nexport var ArgsTable = function ArgsTable(props) {\n  var context = useContext(DocsContext);\n  var id = context.id,\n      storyById = context.storyById;\n\n  var _storyById3 = storyById(id),\n      controls = _storyById3.parameters.controls,\n      subcomponents = _storyById3.subcomponents;\n\n  var _ref6 = props,\n      include = _ref6.include,\n      exclude = _ref6.exclude,\n      components = _ref6.components,\n      sortProp = _ref6.sort;\n  var _ref7 = props,\n      storyName = _ref7.story;\n  var sort = sortProp || (controls === null || controls === void 0 ? void 0 : controls.sort);\n  var main = getComponent(props, context);\n\n  if (storyName) {\n    return /*#__PURE__*/React.createElement(StoryTable, _extends({}, props, {\n      component: main,\n      subcomponents: subcomponents,\n      sort: sort\n    }));\n  }\n\n  if (!components && !subcomponents) {\n    var mainProps;\n\n    try {\n      mainProps = {\n        rows: extractComponentArgTypes(main, context, include, exclude)\n      };\n    } catch (err) {\n      mainProps = {\n        error: err.message\n      };\n    }\n\n    return /*#__PURE__*/React.createElement(PureArgsTable, _extends({}, mainProps, {\n      sort: sort\n    }));\n  }\n\n  if (components) {\n    return /*#__PURE__*/React.createElement(ComponentsTable, _extends({}, props, {\n      components: components,\n      sort: sort\n    }));\n  }\n\n  var mainLabel = getComponentName(main);\n  return /*#__PURE__*/React.createElement(ComponentsTable, _extends({}, props, {\n    components: Object.assign(_defineProperty({}, mainLabel, main), subcomponents),\n    sort: sort\n  }));\n};\nArgsTable.defaultProps = {\n  of: CURRENT_SELECTION\n};","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { combineParameters } from '@storybook/store'; // ============================================================\n// START @storybook/source-loader/extract-source\n//\n// This code duplicated because tree-shaking isn't working.\n// It's not DRY, but source-loader is on the chopping block for\n// the next version of addon-docs, so it's not the worst sin.\n// ============================================================\n\n/**\n * given a location, extract the text from the full source\n */\nfunction extractSource(location, lines) {\n  var start = location.startBody,\n      end = location.endBody;\n\n  if (start.line === end.line && lines[start.line - 1] !== undefined) {\n    return lines[start.line - 1].substring(start.col, end.col);\n  } // NOTE: storysource locations are 1-based not 0-based!\n\n\n  var startLine = lines[start.line - 1];\n  var endLine = lines[end.line - 1];\n\n  if (startLine === undefined || endLine === undefined) {\n    return null;\n  }\n\n  return [startLine.substring(start.col)].concat(_toConsumableArray(lines.slice(start.line, end.line - 1)), [endLine.substring(0, end.col)]).join('\\n');\n} // ============================================================\n// END @storybook/source-loader/extract-source\n// ============================================================\n\n\n/**\n * Replaces full story id name like: story-kind--story-name -> story-name\n * @param id\n */\nvar storyIdToSanitizedStoryName = function storyIdToSanitizedStoryName(id) {\n  return id.replace(/^.*?--/, '');\n};\n\nvar extract = function extract(targetId, _ref) {\n  var source = _ref.source,\n      locationsMap = _ref.locationsMap;\n\n  if (!locationsMap) {\n    return source;\n  }\n\n  var sanitizedStoryName = storyIdToSanitizedStoryName(targetId);\n  var location = locationsMap[sanitizedStoryName];\n\n  if (!location) {\n    return source;\n  }\n\n  var lines = source.split('\\n');\n  return extractSource(location, lines);\n};\n\nexport var enhanceSource = function enhanceSource(story) {\n  var _docs$source;\n\n  var id = story.id,\n      parameters = story.parameters;\n  var storySource = parameters.storySource,\n      _parameters$docs = parameters.docs,\n      docs = _parameters$docs === void 0 ? {} : _parameters$docs;\n  var transformSource = docs.transformSource; // no input or user has manually overridden the output\n\n  if (!(storySource !== null && storySource !== void 0 && storySource.source) || (_docs$source = docs.source) !== null && _docs$source !== void 0 && _docs$source.code) {\n    return null;\n  }\n\n  var input = extract(id, storySource);\n  var code = transformSource ? transformSource(input, story) : input;\n  return {\n    docs: combineParameters(docs, {\n      source: {\n        code: code\n      }\n    })\n  };\n};","import \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport pickBy from 'lodash/pickBy';\n\nvar matches = function matches(name, descriptor) {\n  return Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor);\n};\n\nexport var filterArgTypes = function filterArgTypes(argTypes, include, exclude) {\n  if (!include && !exclude) {\n    return argTypes;\n  }\n\n  return argTypes && pickBy(argTypes, function (argType, key) {\n    var name = argType.name || key;\n    return (!include || matches(name, include)) && (!exclude || !matches(name, exclude));\n  });\n};","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n// Utilities for handling parameters\nimport isPlainObject from 'lodash/isPlainObject';\n/**\n * Safely combine parameters recursively. Only copy objects when needed.\n * Algorithm = always overwrite the existing value UNLESS both values\n * are plain objects. In this case flag the key as \"special\" and handle\n * it with a heuristic.\n */\n\nexport var combineParameters = function combineParameters() {\n  for (var _len = arguments.length, parameterSets = new Array(_len), _key = 0; _key < _len; _key++) {\n    parameterSets[_key] = arguments[_key];\n  }\n\n  var mergeKeys = {};\n  var combined = parameterSets.filter(Boolean).reduce(function (acc, p) {\n    Object.entries(p).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          value = _ref2[1];\n\n      var existing = acc[key];\n\n      if (Array.isArray(value) || typeof existing === 'undefined') {\n        acc[key] = value;\n      } else if (isPlainObject(value) && isPlainObject(existing)) {\n        // do nothing, we'll handle this later\n        mergeKeys[key] = true;\n      } else if (typeof value !== 'undefined') {\n        acc[key] = value;\n      }\n    });\n    return acc;\n  }, {});\n  Object.keys(mergeKeys).forEach(function (key) {\n    var mergeValues = parameterSets.filter(Boolean).map(function (p) {\n      return p[key];\n    }).filter(function (value) {\n      return typeof value !== 'undefined';\n    });\n\n    if (mergeValues.every(function (value) {\n      return isPlainObject(value);\n    })) {\n      combined[key] = combineParameters.apply(void 0, _toConsumableArray(mergeValues));\n    } else {\n      combined[key] = mergeValues[mergeValues.length - 1];\n    }\n  });\n  return combined;\n};"],"names":[],"sourceRoot":""}